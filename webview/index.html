<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self' vscode-resource: 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Scene</title>
</head>
<body>
<div id="info">Description</div>
<select id="viewSelector">
  <option value="top">Top</option>
  <option value="bottom">Bottom</option>
  <option value="left">Left</option>
  <option value="right">Right</option>
  <option value="front">Front</option>
  <option value="back">Back</option>
  <option value="iso">Iso</option>
</select>
<div id="perspectiveToggleDiv">
  <input type="checkbox" id="perspectiveToggle" checked>
  <label for="perspectiveToggle">Perspective</label>
</div>

<script src="<!-- LocalResource:utils.js -->"></script>
<script src="<!-- LocalResource:three.min.js -->"></script>
<script src="<!-- LocalResource:OrbitControls.js -->"></script>
<script src="<!-- LocalResource:tween.js -->"></script>
<script src="<!-- LocalResource:gizmo.js -->"></script>
<script>

function createGrid(scene) {
  let size = 20; // 20x20 grid
  let divisions = 20;

  // Grid for the XZ plane (Right-Left)
  let fadedFront = interpolateColor(new THREE.Color(faceColors.Right), new THREE.Color(0x808080), 0.1);
  let fadedBack = interpolateColor(new THREE.Color(faceColors.Left), new THREE.Color(0x808080), 0.6);
  let gridXZ = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridXZ.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);  // Rotate around the X-axis to lay it flat
  gridXZ.material.opacity = 0.5;
  gridXZ.material.transparent = true;
  scene.add(gridXZ);

  // Grid for the XY plane (Top-Bottom)
  fadedFront = interpolateColor(new THREE.Color(faceColors.Top), new THREE.Color(0x808080), 0.1);
  fadedBack = interpolateColor(new THREE.Color(faceColors.Bottom), new THREE.Color(0x808080), 0.6);
  let gridXY = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridXY.material.opacity = 0.5;
  gridXY.material.transparent = true;
  scene.add(gridXY);

  // Grid for the YZ plane (Front-Back)
  fadedFront = interpolateColor(new THREE.Color(faceColors.Front), new THREE.Color(0x808080), 0.1);
  fadedBack = interpolateColor(new THREE.Color(faceColors.Back), new THREE.Color(0x808080), 0.6);
  let gridYZ = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridYZ.material.opacity = 0.5;
  gridYZ.material.transparent = true;
  gridYZ.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2);  // Rotate around the Z-axis to make it vertical
  scene.add(gridYZ);
}


let scene = new THREE.Scene();
let cameraPersp = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
cameraPersp.position.z = 5;
cameraPersp.position.y = 0;
let orthoCamera = new THREE.OrthographicCamera( window.innerWidth / - 16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / - 16, 0.1, 60000 );
{
  let aspect = window.innerWidth / window.innerHeight;
  let height = window.innerHeight / 16;  // adjust based on your requirements
  let width = height * aspect;

  orthoCamera.left = -width / 2;
  orthoCamera.right = width / 2;
  orthoCamera.top = height / 2;
  orthoCamera.bottom = -height / 2;
  orthoCamera.updateProjectionMatrix();
  orthoCamera.position.z = 5;
  orthoCamera.position.y = 0;
}

camera = cameraPersp;

let renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.width = '100%';  
renderer.domElement.style.height = '100%';
renderer.setPixelRatio(window.devicePixelRatio);
renderer.gammaFactor = 2.2; 
renderer.gammaOutput = true;

const controls = new OrbitControls(camera, renderer.domElement);
//controls.enableRotate = false;

let geometry = new THREE.BoxGeometry();
let material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
let cube = new THREE.Mesh(geometry, material);
scene.add(cube);

createGrid(scene)
gizmoCreate()

function animate() {
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  
  controls.update(); // Add this line to update the controls
  
  TweenUpdate();

  document.getElementById('info').textContent = roundNumber(camera.position.x) + ', ' + roundNumber(camera.position.y) + ', ' + roundNumber(camera.position.z);

  renderer.clear();
  renderer.render(scene, camera);

  gizmoAnimate()

  requestAnimationFrame(animate);
}

animate();

window.addEventListener('message', event => {
  const message = event.data; // The JSON data our extension sent

  switch (message.command) {
    case 'jbeamData':
      const data = message.text;
      console.log(data);
      break;
  }
});

window.addEventListener('resize', function() {
  cameraPersp.aspect = window.innerWidth / window.innerHeight;
  cameraPersp.updateProjectionMatrix();

  // For the orthographic camera
  let aspect = window.innerWidth / window.innerHeight;
  let height = window.innerHeight / 16;  // adjust based on your requirements
  let width = height * aspect;

  orthoCamera.left = -width / 2;
  orthoCamera.right = width / 2;
  orthoCamera.top = height / 2;
  orthoCamera.bottom = -height / 2;
  orthoCamera.updateProjectionMatrix();

  // Update the renderer's size
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
});

document.getElementById("viewSelector").addEventListener("change", function() {
  switch (this.value) {
    case 'top':
      animateCameraMovement(new THREE.Vector3(0, 10, 0));
      break;
    case 'bottom':
      animateCameraMovement(new THREE.Vector3(0, -10, 0));
      break;
    case 'left':
      animateCameraMovement(new THREE.Vector3(-10, 0, 0));
      break;
    case 'right':
      animateCameraMovement(new THREE.Vector3(10, 0, 0));
      break;
    case 'front':
      animateCameraMovement(new THREE.Vector3(0, 0, 10));
      break;
    case 'back':
      animateCameraMovement(new THREE.Vector3(0, 0, -10));
      break;
    case 'iso':
      animateCameraMovement(new THREE.Vector3(10, 10, 10));
      break;
  }
});

document.getElementById("perspectiveToggle").addEventListener("change", function() {
  if (this.checked) {
    camera = cameraPersp;
  } else {
    camera = orthoCamera;
  }
  controls.object = camera;  // Update controls to new camera
  camera.position.z = 5;
  camera.position.y = 0;
  camera.lookAt(0, 0, 0); 
});
</script>
</body>
<style>
#info {
	position: absolute;
	top: 0;
  left:0;
	z-index: 100;
  font-family: monospace;
}
#viewSelector {
	position: absolute;
	top:0;
	width: 80px;
  right:0;
	z-index: 100;
}
#perspectiveToggleDiv {
	position: absolute;
	top: 0;
	right:200px;
	text-align: right;
	z-index: 100;
  vertical-align:middle;
}
body, html, canvas {
  user-select: none;
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: block; /* added this to ensure it's block level */
}
</style>
</html>