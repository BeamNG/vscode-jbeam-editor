<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self' vscode-resource: 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Scene</title>
</head>
<body>
<div id="info">Description</div>
<select id="viewSelector">
  <option value="top">Top</option>
  <option value="bottom">Bottom</option>
  <option value="left">Left</option>
  <option value="right">Right</option>
  <option value="front">Front</option>
  <option value="back">Back</option>
</select>
<div id="perspectiveToggleDiv">
  <input type="checkbox" id="perspectiveToggle" checked>
  <label for="perspectiveToggle">Perspective</label>
</div>

<script src="<!-- LocalResource:three.min.js -->"></script>
<script src="<!-- LocalResource:OrbitControls.js -->"></script>
<script>

function createGrid(scene) {
  let size = 10; // 10x10 grid
  let divisions = 20;

  // Grid for the XZ plane
  let gridXZ = new THREE.GridHelper(size, divisions, new THREE.Color(0xff0000), new THREE.Color(0x550000));
  gridXZ.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);  // Rotate around the X-axis to lay it flat
  scene.add(gridXZ);

  // Grid for the XY plane
  let gridXY = new THREE.GridHelper(size, divisions, new THREE.Color(0x00ff00), new THREE.Color(0x005500));
  scene.add(gridXY);

  // Grid for the YZ plane
  let gridYZ = new THREE.GridHelper(size, divisions, new THREE.Color(0x0000ff), new THREE.Color(0x000055));
  gridYZ.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2);  // Rotate around the Z-axis to make it vertical
  scene.add(gridYZ);
}


let scene = new THREE.Scene();
let cameraPersp = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let orthoCamera = new THREE.OrthographicCamera( window.innerWidth / - 16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / - 16, 0.1, 1000 );
let camera = cameraPersp;

let renderer = new THREE.WebGLRenderer();
document.body.appendChild(renderer.domElement);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.width = '100%';  
renderer.domElement.style.height = '100%';

const controls = new OrbitControls(camera, renderer.domElement);
//controls.enableRotate = false;

let geometry = new THREE.BoxGeometry();
let material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
let cube = new THREE.Mesh(geometry, material);
scene.add(cube);

createGrid(scene)

camera.position.z = 5;
camera.position.y = 0;

function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  controls.update(); // Add this line to update the controls
  renderer.render(scene, camera);
}

animate();

window.addEventListener('message', event => {
  const message = event.data; // The JSON data our extension sent

  switch (message.command) {
    case 'update':
      // Handle the 'update' message
      const text = message.text;
      // Display the text in some HTML element, or use it as you wish
      console.log(text);
      document.getElementById('info').textContent = text;

      break;
  }
});
window.addEventListener('resize', function() {
    // Update camera's aspect ratio
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    // Update the renderer's size
    renderer.setSize(window.innerWidth, window.innerHeight);
});
document.getElementById("viewSelector").addEventListener("change", function() {
    switch (this.value) {
        case 'top':
            camera.position.set(0, 10, 0);
            break;
        case 'bottom':
            camera.position.set(0, -10, 0);
            break;
        case 'left':
            camera.position.set(-10, 0, 0);
            break;
        case 'right':
            camera.position.set(10, 0, 0);
            break;
        case 'front':
            camera.position.set(0, 0, 10);
            break;
        case 'back':
            camera.position.set(0, 0, -10);
            break;
    }
    camera.lookAt(scene.position); // Make the camera look at the center of the scene
});

document.getElementById("perspectiveToggle").addEventListener("change", function() {
    if (this.checked) {
        camera = cameraPersp;
    } else {
        camera = orthoCamera;
    }
    controls.object = camera;  // Update controls to new camera
    camera.position.z = 5;
    camera.position.y = 0;
    camera.lookAt(scene.position); 
});

</script>
</body>
<style>
#info {
	position: absolute;
	top: 0;
  left:0;
	z-index: 100;
}
#viewSelector {
	position: absolute;
	top:0;
	width: 80px;
  right:0;
	z-index: 100;
}
#perspectiveToggleDiv {
	position: absolute;
	top: 0;
	right:400px;
	text-align: right;
	z-index: 100;
}
body, html, canvas {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: block; /* added this to ensure it's block level */
}
</style>
</html>