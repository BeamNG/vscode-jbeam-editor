<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self' vscode-resource: 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Scene</title>
</head>
<body>
<div id="info">Description</div>
<select id="viewSelector">
  <option value="top">Top</option>
  <option value="bottom">Bottom</option>
  <option value="left">Left</option>
  <option value="right">Right</option>
  <option value="front">Front</option>
  <option value="back">Back</option>
  <option value="iso">Iso</option>
</select>
<div id="perspectiveToggleDiv">
  <input type="checkbox" id="perspectiveToggle" checked>
  <label for="perspectiveToggle">Perspective</label>
</div>

<script src="<!-- LocalResource:three.min.js -->"></script>
<script src="<!-- LocalResource:OrbitControls.js -->"></script>
<script src="<!-- LocalResource:tween.js -->"></script>
<script>
const faceColors = {
    Top: 0xff0000,     // Red
    Bottom: 0x0000ff,  // Blue
    Left: 0x00ff00,    // Green
    Right: 0xffff00,   // Yellow
    Front: 0xff00ff,   // Magenta
    Back: 0x00ffff     // Cyan
};
function interpolateColor(color1, color2, factor) {
  return color1.lerp(color2, factor);
}

function createGrid(scene) {
  let size = 20; // 20x20 grid
  let divisions = 20;

  // Grid for the XZ plane (Right-Left)
  let fadedFront = interpolateColor(new THREE.Color(faceColors.Right), new THREE.Color(0x808080), 0.1);
  let fadedBack = interpolateColor(new THREE.Color(faceColors.Left), new THREE.Color(0x808080), 0.6);
  let gridXZ = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridXZ.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);  // Rotate around the X-axis to lay it flat
  gridXZ.material.opacity = 0.5;
  gridXZ.material.transparent = true;
  scene.add(gridXZ);

  // Grid for the XY plane (Top-Bottom)
  fadedFront = interpolateColor(new THREE.Color(faceColors.Top), new THREE.Color(0x808080), 0.1);
  fadedBack = interpolateColor(new THREE.Color(faceColors.Bottom), new THREE.Color(0x808080), 0.6);
  let gridXY = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridXY.material.opacity = 0.5;
  gridXY.material.transparent = true;
  scene.add(gridXY);

  // Grid for the YZ plane (Front-Back)
  fadedFront = interpolateColor(new THREE.Color(faceColors.Front), new THREE.Color(0x808080), 0.1);
  fadedBack = interpolateColor(new THREE.Color(faceColors.Back), new THREE.Color(0x808080), 0.6);
  let gridYZ = new THREE.GridHelper(size, divisions, fadedFront, fadedBack);
  gridYZ.material.opacity = 0.5;
  gridYZ.material.transparent = true;
  gridYZ.rotateOnAxis(new THREE.Vector3(0, 0, 1), Math.PI / 2);  // Rotate around the Z-axis to make it vertical
  scene.add(gridYZ);
}

let gizmoRenderer
let gizmoScene
let gizmoCamera
let gizmoCube
let gizmoCubeEdges
function getContrastingColor(hexcolor) {
    const r = parseInt(hexcolor.slice(1, 3), 16);
    const g = parseInt(hexcolor.slice(3, 5), 16);
    const b = parseInt(hexcolor.slice(5, 7), 16);
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? 'black' : 'white';
}

function createTextTexture(text, bgColor) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;

    const ctx = canvas.getContext('2d');
    const hexColor = `#${bgColor.toString(16).padStart(6, '0')}`;
    ctx.fillStyle = hexColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.font = '40px Arial';
    ctx.fillStyle = getContrastingColor(hexColor);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

function createGizmo() {
  gizmoScene = new THREE.Scene();
  gizmoRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); // set alpha to true for transparent background
  gizmoRenderer.setSize(100, 100); // you can adjust the size as needed
  gizmoRenderer.setClearColor(0x000000, 0); // ensures a transparent background
  document.body.appendChild(gizmoRenderer.domElement);
  // Position the gizmoRenderer's canvas in the top right corner
  gizmoRenderer.domElement.style.position = 'absolute';
  gizmoRenderer.domElement.style.top = '10px';
  gizmoRenderer.domElement.style.right = '10px';
  //gizmoRenderer.domElement.style.border = '1px solid red';
  gizmoRenderer.setPixelRatio(1.2);
  gizmoRenderer.gammaFactor = 2.2; 
  gizmoRenderer.gammaOutput = true;

  let gizmoAspect = 1; //window.innerWidth / window.innerHeight;
  let gizmoFrustumSize = 2; // can be adjusted
  gizmoCamera = new THREE.OrthographicCamera(gizmoFrustumSize * gizmoAspect / -2, gizmoFrustumSize * gizmoAspect / 2, gizmoFrustumSize / 2, gizmoFrustumSize / -2, 1, 1000);
  gizmoCamera.position.set(0, 0, 2); // Adjust as needed
  gizmoCamera.lookAt(0, 0, 0);

  let gizmoCubeGeometry = new THREE.BoxGeometry(1, 1, 1);

  const materials = [
    new THREE.MeshBasicMaterial({ map: createTextTexture('Right', faceColors.Right) }),
    new THREE.MeshBasicMaterial({ map: createTextTexture('Left', faceColors.Left) }),
    new THREE.MeshBasicMaterial({ map: createTextTexture('Top', faceColors.Top) }),
    new THREE.MeshBasicMaterial({ map: createTextTexture('Bottom', faceColors.Bottom) }),
    new THREE.MeshBasicMaterial({ map: createTextTexture('Front', faceColors.Front) }),
    new THREE.MeshBasicMaterial({ map: createTextTexture('Back', faceColors.Back) }),
  ];

  let cubeSize = 0.8;
  let cubeEdgesSize = 1.0;
  gizmoCube = new THREE.Mesh(gizmoCubeGeometry, materials);

  const edges = new THREE.EdgesGeometry(gizmoCube.geometry);
  gizmoCubeEdges = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xaaaaaa }));
  gizmoCubeEdges.position.set(0, 0, 0);
  gizmoCubeEdges.scale.set(cubeEdgesSize, cubeEdgesSize, cubeEdgesSize);

  //let gizmoCubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
  //gizmoCube = new THREE.Mesh(gizmoCubeGeometry, gizmoCubeMaterial);
  gizmoCube.position.set(0, 0, 0);
  gizmoCube.scale.set(cubeSize, cubeSize, cubeSize);
  gizmoScene.add(gizmoCube);
  gizmoScene.add(gizmoCubeEdges);
  
}

let scene = new THREE.Scene();
let cameraPersp = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
cameraPersp.position.z = 5;
cameraPersp.position.y = 0;
let orthoCamera = new THREE.OrthographicCamera( window.innerWidth / - 16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / - 16, 0.1, 1000 );
orthoCamera.position.z = 5;
orthoCamera.position.y = 0;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

let camera = cameraPersp;

let renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.width = '100%';  
renderer.domElement.style.height = '100%';
renderer.setPixelRatio(1);
renderer.gammaFactor = 2.2; 
renderer.gammaOutput = true;

const controls = new OrbitControls(camera, renderer.domElement);
//controls.enableRotate = false;

let geometry = new THREE.BoxGeometry();
let material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
let cube = new THREE.Mesh(geometry, material);
scene.add(cube);

createGrid(scene)
createGizmo()



function animate() {
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  
  controls.update(); // Add this line to update the controls
  
  TweenUpdate();

  renderer.clear();
  renderer.render(scene, camera);

  gizmoCube.quaternion.copy(camera.quaternion).invert()
  gizmoCubeEdges.quaternion.copy(gizmoCube.quaternion)
  gizmoRenderer.render(gizmoScene, gizmoCamera);
  requestAnimationFrame(animate);
}

animate();

window.addEventListener('message', event => {
  const message = event.data; // The JSON data our extension sent

  switch (message.command) {
    case 'update':
      // Handle the 'update' message
      const text = message.text;
      // Display the text in some HTML element, or use it as you wish
      console.log(text);
      document.getElementById('info').textContent = text;

      break;
  }
});
window.addEventListener('resize', function() {
  console.log('RESIZE', camera.aspect)
  // Update camera's aspect ratio
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  // Update the renderer's size
  renderer.setSize(window.innerWidth, window.innerHeight);
});
document.getElementById("viewSelector").addEventListener("change", function() {
  switch (this.value) {
    case 'top':
      camera.position.set(0, 10, 0);
      break;
    case 'bottom':
      camera.position.set(0, -10, 0);
      break;
    case 'left':
      camera.position.set(-10, 0, 0);
      break;
    case 'right':
      camera.position.set(10, 0, 0);
      break;
    case 'front':
      camera.position.set(0, 0, 10);
      break;
    case 'back':
      camera.position.set(0, 0, -10);
      break;
    case 'iso':
      camera.position.set(10, 10, 10);
      break;
  }
  camera.lookAt(scene.position); // Make the camera look at the center of the scene
});

document.getElementById("perspectiveToggle").addEventListener("change", function() {
  if (this.checked) {
    camera = cameraPersp;
  } else {
    camera = orthoCamera;
  }
  controls.object = camera;  // Update controls to new camera
  camera.position.z = 5;
  camera.position.y = 0;
  camera.lookAt(scene.position); 
});
function switchCameraBasedOnFace(materialIndex) {
  targetCameraPosition = new THREE.Vector3();
  if (materialIndex === 0) {
    targetCameraPosition.set(10, 0, 0); // Right
  } else if (materialIndex === 1) {
    targetCameraPosition.set(-10, 0, 0); // Left
  } else if (materialIndex === 2) {
    targetCameraPosition.set(0, 10, 0); // Top
  } else if (materialIndex === 3) {
    targetCameraPosition.set(0, -10, 0); // Bottom
  } else if (materialIndex === 4) {
    targetCameraPosition.set(0, 0, 10); // Front
  } else if (materialIndex === 5) {
    targetCameraPosition.set(0, 0, -10); // Back
  }
  camera.lookAt(scene.position);

  // Create a new tween for the camera
  new Tween(camera.position)
    .to(targetCameraPosition, 300)
    .easing(Easing.Quadratic.Out)
    .onUpdate(function() {
      camera.up.set(0, 1, 0)
      camera.lookAt(scene.position);
    })
    .start();
}

function onGizmoClick(event) {
  event.preventDefault();

  const rect = gizmoRenderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, gizmoCamera);

  const intersects = raycaster.intersectObject(gizmoCube, true);
  console.log('>>> onGizmoClick', intersects, intersects[0])

  if (intersects.length > 0 && intersects[0].face) {
    switchCameraBasedOnFace(intersects[0].face.materialIndex);
  }
}
gizmoRenderer.domElement.addEventListener('click', onGizmoClick);

</script>
</body>
<style>
#info {
	position: absolute;
	top: 0;
  left:0;
	z-index: 100;
}
#viewSelector {
	position: absolute;
	top:0;
	width: 80px;
  right:0;
	z-index: 100;
}
#perspectiveToggleDiv {
	position: absolute;
	top: 0;
	right:400px;
	text-align: right;
	z-index: 100;
}
body, html, canvas {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: block; /* added this to ensure it's block level */
}
</style>
</html>